#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Apr  2 19:27:49 2021

@author: bcbirkel
"""

from obspy import read, read_inventory
from obspy.signal.filter import bandpass
# import pandas as pd
# from mpl_toolkits.basemap import Basemap
import matplotlib.pyplot as plt
import numpy as np
from obspy.signal.invsim import simulate_seismometer, corn_freq_2_paz
from obspy.geodetics import gps2dist_azimuth
from obspy.io.sac import sacpz
from obspy.io.sac import attach_paz
from obspy.io.gse2.paz import read_paz
import os
from obspy.core import Trace, Stream, AttribDict
from obspy.signal.rotate import rotate_ne_rt
import math
import obspy.realtime.signal as signal
from obspy.core.utcdatetime import UTCDateTime
import shutil

#Ignore warnings due to python 2 and 3 conflict
import warnings
warnings.filterwarnings("ignore")

slurm_mo = 3.131630e+30 #Nm 
mo_real = 5.1e23 #from GCMT
scalar_mo = 6.29e+23 #dyne-cm
scalar_mo = 6.29e+26 #Nm

mo_adj = slurm_mo/scalar_mo
mo_adj_cm = mo_adj/100


# %% Set parameters
#set event

event_no = 0
events = ['lahabra_2014', 'beverlyhills_2001', 'chatsworth_2007', 'chinohills_2008', 'inglewood_2009']
event = events[event_no]

dataPath = '/Users/bcbirkel/Documents/GitHub/LaBasin/CompiledEvents/lahabra_2014/allData/fixed/'
synPath = '/Users/bcbirkel/Documents/GitHub/LABasin/Hercules/runSim/SACfiles/'
# rgPath = '/Users/bcbirkel/Documents/GitHub/LABasin/CompiledEvents/' + event + '/GravesSyn/CVM-S4/extracted/'
rgPath = '/Users/bcbirkel/Documents/GitHub/LABasin/CompiledEvents/lahabra_2014/GravesSyn/synthetics_stations/CVM-S4/'

if event_no == 0:
    event_title = 'lahabra'
    event_lat = 33.9325
    event_lon = -117.9158
elif event_no == 3:
    event_title = 'chinohills'
    event_lat = 33.9465
    event_lon = -117.7667
elif event_no == 4:
    event_title = 'inglewood'
    event_lat = 33.9377
    event_lon = -118.3357
elif event_no == 2:
    event_title = 'chatsworth'
    event_lat = 34.2983
    event_lon = -118.6255
elif event_no == 1:
    event_title = 'beverlyhills'
    event_lat = 34.0541
    event_lon = -118.3929
else: 
    print('unknown event file')
    
stream_dataZ = read(dataPath + "*Z_vel.SAC") 
for tr in stream_dataZ:
    tr.stats.channel = 'Z'
stream_dataR = read(dataPath + "*R_vel.SAC") 
for tr in stream_dataR:
    tr.stats.channel = 'R'
stream_dataT = read(dataPath + "*T_vel.SAC") 
for tr in stream_dataT:
    tr.stats.channel = 'T'


stream_hercZ = read(synPath + "*Z.SAC") 
for tr in stream_hercZ:
    tr.stats.channel = 'Z'
stream_hercR = read(synPath + "*R.SAC") 
for tr in stream_hercR:
    tr.stats.channel = 'R'
stream_hercT = read(synPath + "*T.SAC") 
for tr in stream_hercT:
    tr.stats.channel = 'T'    
    

stream_rgZ = read(rgPath + "*Z_vel.SAC") 
for tr in stream_rgZ:
    tr.stats.channel = 'Z'
stream_rgR = read(rgPath + "*R_vel.SAC") 
for tr in stream_rgR:
    tr.stats.channel = 'R'
stream_rgT = read(rgPath + "*T_vel.SAC") 
for tr in stream_rgT:
    tr.stats.channel = 'T'

# %% STATIONS
# stationFile = "/Users/bcbirkel/Documents/GitHub/LABasin/all_stationmaster.txt"
stationFile = "/Users/bcbirkel/Documents/GitHub/LABasin/stationLists/stationsByEvent/lahabra_stations.txt"

# Load station coords into arrays, many more stations than used
st_netw  = []
st_name  = []
st_dist  = []
st_az    = []
st_baz   = []
st_lat   = []
st_lon   = []

# strip station file
staCoord = open(stationFile, 'r')
lines = staCoord.readlines()
for line in lines:
    split_line = line.split()
    st_netw.append(split_line[0])
    st_name.append(split_line[1])
    st_lat.append(float(split_line[2]))
    st_lon.append(float(split_line[3]))
    [distance,az,baz] = gps2dist_azimuth(event_lat, event_lon, float(split_line[2]), float(split_line[3])) # Get traveltime and azimuth
    print(distance/1000.,az,baz)
    st_dist.append(distance/1000.) # distance
    st_az.append(az) # azimuth
    st_baz.append(baz) # back-azimuth
            
    
# %% PLOTTING

stream_data = stream_dataR + stream_dataT + stream_dataZ
stream_rg = stream_rgZ + stream_rgR + stream_rgT
stream_herc = stream_hercZ + stream_hercR + stream_hercT

# figures for distance plots
figZ = plt.figure(2, figsize=[8,5])
aZ = figZ.add_subplot(1, 1, 1)
figR = plt.figure(3, figsize=[8,5])
aR = figR.add_subplot(1, 1, 1)
figT = plt.figure(4, figsize=[8,5])
aT = figT.add_subplot(1, 1, 1)


# set up vars to loop through
figs = [figZ,figR,figT]
axes = [aZ,aR,aT]
channels = ["Z","R","T"]

xmax = 80
ymax = 80

# loop through each component
for i in range(len(axes)):
    fig = figs[i]
    a = axes[i]
    cha = channels[i]
    
    a.set_ylabel("Distance from source (km)")    
    a.set_xlabel("Time (s)")
    a.set_title("Data (black) v. RG grid (blue) for " + event +  " - " + cha)\
    # a.set_title("Data (black) v. RG grid (blue) v. Hercules Syn (green) for " + event +  " - " + cha)
    
    # for i in range(len(st_name)):
    #     for tr in stream_rg:
    #         if tr.stats.station == st_name[i] and tr.stats.channel == cha:
    #             if st_name[i] == "SDD" or st_name[i] == "WTT2" or st_name[i] == "13883" or st_name[i] == "CJM" or st_name[i] == "ADO" or st_name[i] == "DSN5" or st_name[i] == "SOF": # and tr.stats.network == 'CI':
    #                 for sytr in stream_herc:
    #                     if sytr.stats.channel == cha and sytr.stats.station == st_name[i]:
    #                         for datatr in stream_data:
    #                             if datatr.stats.channel == cha and datatr.stats.station == st_name[i]:
    #                                 print(st_netw[i] + " " + st_name[i] + " " + cha)
    #                                 tr.stats.dist = st_dist[i]
    #                                 dist = st_dist[i]
    #                                 gain = 20
    #                                 sytr.stats.delta = 0.25
                                    
                                    
    #                                 tr.filter("bandpass", freqmin=0.1, freqmax=1,zerophase=True)
    #                                 sytr.filter("bandpass", freqmin=0.1, freqmax=1,zerophase=True)
    #                                 datatr.filter("bandpass", freqmin=0.1, freqmax=1,zerophase=True)
            
    #                                 a.set_ylim(0,ymax)
    #                                 a.set_xlim(0,xmax)
                                    
    #                                 # sytr.stats.starttime = tr.stats.starttime
                                    
                                    
    #                                 # plot synthetics on top of data
                                    
    #                                 # HERC
    #                                 # a.plot(np.arange(0,200.05,0.25), sytr.data*gain*0.0001+dist,c="g",linewidth=0.5)
                                    
    #                                 # DATA
    #                                 a.plot(datatr.times(), datatr.data*gain+dist,c="k",linewidth=0.5)
                                    
    #                                 # ROB
    #                                 if cha == "Z":
    #                                     a.plot(tr.times(), -(tr.data*gain)+tr.stats.dist,c="b",linewidth=0.5)
    #                                 else:
    #                                     a.plot(tr.times(), (tr.data*gain)+tr.stats.dist,c="b",linewidth=0.5)
            
                                    
    #                                 if dist < ymax: 
    #                                     a.text(xmax-5,dist,sytr.stats.station)
    #                                     a.text(xmax-5,dist-3,"data max:" + str(max(datatr.data)))
    #                                     a.text(xmax-5,dist-6,"syn max:" + str(max(tr.data)))
                                        
    for i in range(len(st_name)):
        for tr in stream_rg:
            if tr.stats.station == st_name[i] and tr.stats.channel == cha:
                if st_name[i] == "OLI" or st_name[i] == "PSR" or st_name[i] == "RIO" or st_name[i] == "STG" or st_name[i] == "VCS" or st_name[i] == "QUG" or st_name[i] == "STS": # and tr.stats.network == 'CI':
                    for sytr in stream_herc:
                        if sytr.stats.channel == cha and sytr.stats.station == st_name[i]:
                            for datatr in stream_data:
                                if datatr.stats.channel == cha and datatr.stats.station == st_name[i]:
                                    print(st_netw[i] + " " + st_name[i] + " " + cha)
                                    tr.stats.dist = st_dist[i]
                                    dist = st_dist[i]
                                    gain = 20
                                    sytr.stats.delta = 0.25
                                    
                                    
                                    tr.filter("bandpass", freqmin=0.1, freqmax=1,zerophase=True)
                                    sytr.filter("bandpass", freqmin=0.1, freqmax=1,zerophase=True)
                                    datatr.filter("bandpass", freqmin=0.1, freqmax=1,zerophase=True)
            
                                    a.set_ylim(0,ymax)
                                    a.set_xlim(0,xmax)
                                    
                                    # sytr.stats.starttime = tr.stats.starttime
                                    
                                    
                                    # plot synthetics on top of data
                                    
                                    # HERC
                                    # a.plot(np.arange(0,200.05,0.25), sytr.data*gain*0.0001+dist,c="g",linewidth=0.5)
                                    
                                    # DATA
                                    a.plot(datatr.times(), datatr.data*gain+dist,c="k",linewidth=0.5)
                                    
                                    # ROB
                                    if cha == "Z":
                                        a.plot(tr.times(), -(tr.data*gain)+tr.stats.dist,c="b",linewidth=0.5)
                                    else:
                                        a.plot(tr.times(), (tr.data*gain)+tr.stats.dist,c="b",linewidth=0.5)
            
                                    
                                    if dist < ymax: 
                                        a.text(xmax-5,dist,sytr.stats.station)
                                        a.text(xmax-5,dist-3,"data max:" + str(max(datatr.data)))
                                        a.text(xmax-5,dist-6,"syn max:" + str(max(tr.data)))
                                        
                            
                    
plt.show()
    
