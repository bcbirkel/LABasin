#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Created on Fri Jan 17 11:05:48 2020

@author: bcbirkel
"""

from obspy import UTCDateTime
from obspy import Stream
from obspy import read
from obspy.geodetics import gps2dist_azimuth
import numpy as np
import os
import matplotlib.pyplot as plt
import time

import sys # don't show any warnings
import warnings

if not sys.warnoptions:
    warnings.simplefilter("ignore")

show_data = 0
start_time_wc = time.time()

ev_no = 0
min_dist = 0
max_dist = 60
plot_scale_fac = 0.05
start_buff = 10
end_buff = 110
filt = True
freq_min = 0.1
freq_max = 0.5
taper = True
taper_frac = 0.05
show_H = True
show_S = False
show_H_simp = False
show_S_simp = False
show_data = True
norm_each = False
basin = True
basin_width = 15
motion = 'vel'
com_time  = True
rotated = False
CI_only = True


#%%
# compare stewart and taborda synthetics

#import os
#from run_JS_syn import run_JS_syn
#
#sta_code_rt, sta_num = run_JS_syn()
#
#figs = [7,8,9]


#run_RT_compare(sta_code_rt, sta_num, figs)
os.chdir('/Users/bcbirkel/Documents/Research/LABasin/stewart_synthetics')
from run_JS_syn               import run_JS_syn

sta_code_rt,sta_num,time_js,stN_js,stE_js,stZ_js = run_JS_syn(ev_no)


events = ['15481673', '14383980', '10410337', '14312160', '970387']
event_no = events[ev_no]
vmodel = ['cvmhn', 'cvmhy', 'cvms400-100', 'cvms426-223']

#try 'cvms426-223' for now
vmodel = 'S'

	#%% find event details for origin time, lat, lon
ev_file = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/event_list.txt'
file_ev = open(ev_file, 'r')
for line in file_ev:           # pull numbers off the rest of the lines
	split_line = line.split()
	event = split_line[0]
	if event == event_no:
		ev_lat       = float(split_line[3])
		ev_lon       = float(split_line[2])
		t1           = UTCDateTime(split_line[5])
		date_label  = split_line[5][0:10]
		year1        = split_line[5][0:4]
print(event_no + str(t1) + ' ' + date_label + ' ' + year1 + '  ' + str(ev_lat) + ' ' + str(ev_lon))

	#%% find event details for origin time, lat, lon
badt_file = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_data/bad_trace.txt'
file_badt = open(badt_file, 'r')
badt_lines = file_badt.readlines()
badt_event   = []
badt_station = []
badt_compo   = []

for line in badt_lines:           # pull numbers off all the lines
	split_line = line.split()
	badt_event.append(  split_line[0])
	badt_station.append(split_line[1])
	badt_compo.append(  split_line[2])
print(str(len(badt_event)) + ' bad traces in list')

#%% Open station location file
sta_file = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/ricardo_stations.txt'
file_st = open(sta_file, 'r')
line = file_st.readline()      # read first line to skip header information
lines = file_st.readlines()
print(str(len(lines)) + ' stations read from ' + sta_file)

# Load station coords into arrays, many more stations than used
station_index = range(len(lines))
st_num   = []
st_netw  = []
st_name  = []
st_dist  = []
st_az    = []
st_baz   = []
st_lat   = []
st_lon   = []
for line in lines:
	split_line = line.split()
	st_num.append( split_line[0])
	st_netw.append(split_line[2])
	st_name.append(split_line[3])
	st_lat.append( split_line[4])
	st_lon.append( split_line[5])
	distance = gps2dist_azimuth( ev_lat, ev_lon, float(split_line[4]), float(split_line[5])) # Get traveltime and azimuth
	st_dist.append(distance[0]/1000.) # azimuth
	st_az.append(distance[1]) # azimuth
	st_baz.append(distance[2]) # back-azimuth
print('number of stations in list is ' + str(len(st_num)) + ' or ' + str(station_index))

#%% Load data and synthetic waveforms
st_dat = Stream()
st_synE = Stream()
st_synN = Stream()
st_synZ = Stream()
if vmodel == 'H':
	fname_dat     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_data/vel/ve_' + event_no + '.mseed'
	fname_synE     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_syn/vel/cvms400-100/ve_'  + event_no + '_cvms400-100.mseed'
	fname_synN     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_syn/vel/cvms400-100/vn_'  + event_no + '_cvms400-100.mseed'
	fname_synZ     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_syn/vel/cvms400-100/vz_'  + event_no + '_cvms400-100.mseed'
elif vmodel == 'S':
	fname_dat     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_data/vel/ve_' + event_no + '.mseed'
	fname_synE     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_syn/vel/cvms426-223/ve_'  + event_no + '_cvms426-223.mseed'
	fname_synN     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_syn/vel/cvms426-223/vn_'  + event_no + '_cvms426-223.mseed'
	fname_synZ     = '/Users/bcbirkel/Documents/Research/LABasin/PyCode LAB/ricardo/Mseed_syn/vel/cvms426-223/vz_'  + event_no + '_cvms426-223.mseed'
st_dat=read(fname_dat)
st_synE=read(fname_synE)
st_synN=read(fname_synN)
st_synZ=read(fname_synZ)
print('In sgram file ' + str(st_synZ[609].data[0]) + '  ' + st_synZ[609].stats.station + '  ' + str(len(st_synZ)))
print('In arrays st_name[609] ' + st_name[609] + ' st_name[610] ' + st_name[610])
print('In arrays st_name[0] ' + st_name[0] + ' st_name[1] ' + st_name[1])
print('1st data trace has : ' + str(len(st_synE[0].data)) + ' time pts ')
print('synE has ' + str(len(st_synE)) + ' traces')
print('synN has ' + str(len(st_synN)) + ' traces')
print('synZ has ' + str(len(st_synZ)) + ' traces')
print(st_synE)


"""
#%%# select data by distance (and azimuth?), and cull synthetics to match data
st_dat_select = Stream()
st_synE_select = Stream()
st_synN_select = Stream()
st_synZ_select = Stream()
for tr in st_dat: # examine traces one by one
	if tr.stats.network == 'CI' or CI_only == False:
		for ii in range(len(st_name)):  # find matching entry in station roster
			if (tr.stats.network == st_netw[ii] and tr.stats.station == st_name[ii]): # find station in inventory
				if (st_dist[ii] < max_dist) and (st_dist[ii] > min_dist): # exclude stations too close or too far
					# basin is roughly within 15 km of these 3 stations
					distance = gps2dist_azimuth( 33.99053, -118.36171, float(st_lat[ii]), float(st_lon[ii])) # station BHP
					dist1 = distance[0]/1000  # convert m to km
					distance = gps2dist_azimuth( 33.88110, -118.17568, float(st_lat[ii]), float(st_lon[ii])) # station LTP
					dist2 = distance[0]/1000
					distance = gps2dist_azimuth( 33.80776, -117.98116, float(st_lat[ii]), float(st_lon[ii])) # station BRE
					dist3 = distance[0]/1000
#					print(tr.stats.station + ' ' + str(dist1) + ' ' + str(dist2) + ' ' + str(dist3))
					if basin == False or (dist1 < basin_width) or (dist2 < basin_width) or (dist3 < basin_width):  # keep stations only within X km of basin axis
#						print('selected: ' + tr.stats.station)
#						tr.stats.distance = st_dist[ii] # add distance to trace metadata
#						st_datE_select += tr
						tr.stats.distance = st_dist[ii] # add distance to trace metadata
						st_synE[ii].stats.distance = st_dist[ii]
						st_synN[ii].stats.distance = st_dist[ii]
						st_synZ[ii].stats.distance = st_dist[ii]
						st_dat_select += tr
						st_synE_select += st_synE[ii]
						st_synN_select += st_synN[ii]
						st_synZ_select += st_synZ[ii]
						print(tr.stats.station + ' counter ' + str(ii) + ' ' + 'num ' + str(int(st_num[ii])))
					else:
						print('Not in basin: '  + tr.stats.station)
				else:
					print('Too far: '  + tr.stats.station)
print('now data has ' + str(len(st_dat_select)) + ' traces')
print('now synH has '  + str(len(st_synE_select)) + ' traces')
print('now synS has '  + str(len(st_synN_select)) + ' traces')
print('now synS has '  + str(len(st_synZ_select)) + ' traces')


	#%%  reject data and sythetics on bad trace list, either individual components or A for all components
st_dat_good = Stream()
for tr in st_dat_select: # examine traces one by one
	do_write = 1
	for ii in range(len(badt_event)):
		if event_no == badt_event[ii] and tr.stats.station == badt_station[ii]: # find station in inventory
			if badt_compo[ii] == 'A' or badt_compo[ii] == 'E' or badt_compo[ii] == 'N' or badt_compo[ii] == 'Z':
				do_write = 0
	if do_write == 1:
		st_dat_good += tr
print('After rejecting labeled bad traces ones, dat has '       + str(len(st_dat_good))       + ' traces')
st_synE_good = Stream()
for tr in st_synE_select: # examine traces one by one
	do_write = 1
	for ii in range(len(badt_event)):
		if event_no == badt_event[ii] and tr.stats.station == badt_station[ii]: # find station in inventory
			if badt_compo[ii] == 'E' or badt_compo[ii] == 'A':
				do_write = 0
	if do_write == 1:
		st_synE_good += tr
print('After rejecting labeled bad traces ones, synE has '       + str(len(st_synE_good))       + ' traces')

st_synN_good = Stream()
for tr in st_synN_select: # examine traces one by one
	do_write = 1
	for ii in range(len(badt_event)):
		if event_no == badt_event[ii] and tr.stats.station == badt_station[ii]: # find station in inventory
			if badt_compo[ii] == 'N' or badt_compo[ii] == 'A':
				do_write = 0
	if do_write == 1:
		st_synN_good += tr
print('After rejecting labeled bad traces ones, synN has '       + str(len(st_synN_good))       + ' traces')

st_synZ_good = Stream()
for tr in st_synZ_select: # examine traces one by one
	do_write = 1
	for ii in range(len(badt_event)):
		if event_no == badt_event[ii] and tr.stats.station == badt_station[ii]: # find station in inventory
			if badt_compo[ii] == 'Z' or badt_compo[ii] == 'A':
				do_write = 0
	if do_write == 1:
		st_synZ_good += tr
print('After rejecting labeled bad traces ones, synZ has '       + str(len(st_synZ_good))       + ' traces')
"""

st_dat_good = st_dat
st_synE_good = st_synE
st_synN_good = st_synN
st_synZ_good = st_synZ

	#%%  detrend, taper, filter
if taper:
	st_dat_good.detrend( type='simple')
	st_synE_good.detrend(type='simple')
	st_synN_good.detrend(type='simple')
	st_synZ_good.detrend(type='simple')
if filt:
	st_dat_good.filter( 'bandpass', freqmin=freq_min, freqmax=freq_max, corners=4, zerophase=True)
	st_synE_good.filter('bandpass', freqmin=freq_min, freqmax=freq_max, corners=4, zerophase=True)
	st_synN_good.filter('bandpass', freqmin=freq_min, freqmax=freq_max, corners=4, zerophase=True)
	st_synZ_good.filter('bandpass', freqmin=freq_min, freqmax=freq_max, corners=4, zerophase=True)
if taper:
	st_dat_good.detrend( type='simple')
	st_synE_good.detrend(type='simple')
	st_synN_good.detrend(type='simple')
	st_synZ_good.detrend(type='simple')

"""
	#%%
	# plot traces
if vmodel == 'S':
	fig_index = 10
elif vmodel == 'H':
	fig_index = 11
plt.close(fig_index)
plt.figure(fig_index,figsize=(10,8))
plt.xlim(-start_buff,end_buff)
plt.ylim(min_dist,max_dist)


	# find max
maxE = 0
for tr in st_synE_good:
	tr_max = max(abs(tr.data))*tr.stats.distance
	if tr_max > maxE:
		maxE = tr_max
maxN = 0
for tr in st_synN_good:
	tr_max = max(abs(tr.data))*tr.stats.distance
	if tr_max > maxN:
		maxN = tr_max
maxZ = 0
for tr in st_synZ_good:
	tr_max = max(abs(tr.data))*tr.stats.distance
	if tr_max > maxZ:
		maxZ = tr_max
print('Max E, N, and Z synthetic are ' + str(maxE) + '  ' + str(maxN) + '  ' + str(maxZ))

max_all = max(maxZ, maxN, maxE)
plot_fac = plot_scale_fac * (max_dist - min_dist) / max_all

if show_data:
	for tr in st_dat_good:
		dist_offset = tr.stats.distance # km
		ttt = np.arange(len(tr.data)) * tr.stats.delta + (tr.stats.starttime - t1)
#		if red_plot == 1:
#			shift = red_time + (dist_offset - red_dist) * red_slow
#			ttt = ttt - shift
#		plt.plot(ttt, (tr.data - np.median(tr.data))*plot_scale_fac /(tr.data.max()
#			- tr.data.min()) + dist_offset, color = 'green')
		plt.plot(ttt, (tr.data - np.median(tr.data))*plot_scale_fac /(tr.data.max()
			- tr.data.min()) + dist_offset, color = 'black')
		print(str(tr.stats.distance) + ' distance ' + tr.stats.station + ' station')	#plt.title(fname1)

#print labels whether or not data is shown
for tr in st_dat_good:
	dist_offset = tr.stats.distance # km
	plt.text(s = tr.stats.network + ' ' + tr.stats.station ,x = end_buff*0.95,y = dist_offset
		    + max_dist*0.015, color = 'black')  #label traces

for tr in st_synE_good:
	dist_offset = tr.stats.distance
	ttt = np.arange(len(tr.data)) * tr.stats.delta + (tr.stats.starttime - t1)#	These lines used to cause a crash in Spyder
	plt.plot(ttt, (tr.data * plot_fac * tr.stats.distance) + dist_offset, color = 'black')

for tr in st_dat_good:
	dist_offset = tr.stats.distance # km
	plt.text(s = tr.stats.network + ' ' + tr.stats.station ,x = end_buff*0.95,y = dist_offset
		    + max_dist*0.015, color = 'black')  #label traces

for tr in st_synN_good:
	dist_offset = tr.stats.distance
	ttt = np.arange(len(tr.data)) * tr.stats.delta + (tr.stats.starttime - t1)#	These lines used to cause a crash in Spyder
	plt.plot(ttt, (tr.data * plot_fac * tr.stats.distance) + dist_offset, color = 'green')

for tr in st_synZ_good:
	dist_offset = tr.stats.distance
	ttt = np.arange(len(tr.data)) * tr.stats.delta + (tr.stats.starttime - t1)#	These lines used to cause a crash in Spyder
	plt.plot(ttt, (tr.data * plot_fac * tr.stats.distance) + dist_offset, color = 'red')
    
"""

fig = plt.figure(10)
sp1, sp2 = fig.add_subplot(211), fig.add_subplot(211)
sp1.plot(time_js+start_time_wc, stE_js)
sp2.plot(st_synE[0], st_synE[1])

#fig.xlabel('Time (s)')
#fig.ylabel('Epicentral distance from event (km)')
#plt.title(fname1[8:18] + ' vs ' + fname2[8:18])
#fig.title('Syn ' + date_label + ' ' + event_no + ' E-black N-green Z-red of vmodel ' + vmodel)
plt.show()

	#  Save processed files
#	fname1 = 'Pro_Files/HD' + date_label1 + 'sel.mseed'
#	fname2 = 'Pro_Files/HD' + date_label2 + 'sel.mseed'
#	st1good.write(fname1,format = 'MSEED')
#	st2good.write(fname2,format = 'MSEED')

elapsed_time_wc = time.time() - start_time_wc
print('This job took ' + str(elapsed_time_wc) + ' seconds')
	#os.system('say "Done"')